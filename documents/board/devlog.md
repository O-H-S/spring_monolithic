# `Board(게시판)` 개발 기록

## TO-DO
* RESTful API 작성하기(구현, 테스트 코드, RestDocs)
  * 게시판(Board)
    * ~~게시판 생성~~
    * ~~게시판 정보 조회~~
    * 게시판 설정 변경 : ~~제목~~, 소개, 
    * 
  * 게시글(Post)
    * 게시글 생성
    * 게시글 상세 조회
    * 게시글 삭제
  * 댓글(Comment)
    * 댓글 생성
    * 댓글 조회
    * 댓글 삭제  

* 기능
  * 게시글 검색
  * 게시글 답변
  * 댓글 답변
  * 권한(게시글 쓰기, 읽기, 댓글 작성)
  * 정렬하여 조회(조회순, 추천순, 댓글순)
  * 비밀글
    
* 최적화
  - ~~테스트를 위해 대량의 게시물 빠르게 생성하기(JDBC로 직접 Bulk insert)~~
  - ~~캐시를 이용한 전체 게시물 개수 조회~~ 
  - 읽기 성능 
  - 캐싱 
    - ~~간단한 로컬 캐시 구현~~ 
      - ConcurrentHashMap<Integer, AtomicLong> 로 바꾸기
    - 로컬 캐시 라이브러리 연동(EnCache or Caffeine)
    - 글로벌 캐시 연동(Redis or Memcached)



  
## Problem / Error
* 테스트 여러번 할수록 시간이 점점 짧아지는 정확한 이유 파악하기

## Side Notes
* 대량의 Post 데이터 insert 테스트 코드
  * Post Entity는 채번 전략이 IDENTITY이므로, DB에 Insert 쿼리를 보낸 후 생성된 id값을 받아와야한다.(데이터베이스 round-trip) (id 값은 영속성 컨텍스트 관리를 위해 사전에 필요하다.) 따라서, 일괄적으로 insert 하는 것이 불가능하다.
  * 만약 id 할당을 미룬다면, 차후에 동일한 entity의 접근이 일어날경우 동작을 예측하기 힘들어진다.
  * IDENTITY에서 MySQL은 AUTO_INCREMENT를 PK 컬럼에 설정한다.
  * SEQUENCE로 바꾸면? -> mysql은 시퀀스 객체를 지원하지 않았다.(8.0이상부터는 지원하지만 hibernate가 아직 구현하지 않았다?)
  * TABLE 은? ->
  * 따라서, saveall을 사용하더라도 배치되어 처리되지 않는다.
  * 단순히, 테스트 데이터를 밀어넣는건데 영속성 관리가 필요한가? -> JDBC를 직접 사용하자.
    

* Post count 캐시
  * 분산 구조가 아니므로, 굳이 redis를 사용하지 않고 로컬 캐시로 간단하게 구현
  * ConcurrentHashMap<(BoradID), Long> 
  * 만약 한 게시판에 글 쓰기 요청이 몰린다면? 단순 ConcurrentHashMap의 compute 메소드는 key 값마다 lock을 거는게 아니라, bucket단위로 락을 건다. bucket은 여러개의 key를 포함한다.
  * AtomicLong으로 바꾸는 방법 생각해보자. CAS 방식으로 Lock보다 더 빠르다. 
  * 더 자세한 내용 : https://jiwondev.tistory.com/211
  * 만약 부모 트랜잭션에서 이 Post write 트랜잭션을 호출할 때, 변경된 cache 값을 즉시 사용할 수 있도록 우선 증가시켜놓고 롤백 시에 다시 차감한다


* 대량의 게시글들이 존재하는 게시판에서 페이지 이동시 간헐적으로 딜레이 발생. (1000만개, 앞 페이지에서도 발생)
  * 하지만 이상하게 브라우저에서는 화면이 일찍 로드됨. (페이지 로딩 바가 쓰레드 종료때까지 유지됨)
  * 프로파일링 결과, 타임리프의 render 관련하여 시간이 많이 소요되어 쓰레드 종료가 늦어짐을 확인.
  * 원인 : 타임리프 템플릿에서, 모든 페이지의 개수만큼 html 요소를 생성하는 로직(페이지 버튼 관련)이 있었음. 쓰레드가 페이지 렌더링을 기다리게 되면서, 쓰레드가 고갈되어 타임아웃 전까지 새로운 요청은 대기하는 상태가 발생함.
  * 페이지 관련 html 요소 생성 시간 복잡도를 상수로 바꾸고, 차후 비슷한 문제 예방과 DB 커넥션 풀을 점유 시간을 줄이기 위해 OSIV를 false로 바꿈.  
  * 프로파일링을 활용하지 않았다면, legacy 코드를 다시 살펴볼 생각도 못했을 것. 또한, view 컨트롤러의 테스트 코드를 작성했다면 원인 파악이 좀 더 쉬웠을 것.